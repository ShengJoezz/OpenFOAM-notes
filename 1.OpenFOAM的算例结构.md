# 总述

一个完整的openFoam算例结构需要有三个部分组成:

* `constant`文件夹，其中用于存储各种网格数据以及物理量
* `system`文件夹，其中用于存储一系列求解过程中的参数
* `time`文件(并不意味着就真实存在`time`文件夹)，往往是一系列数字文件，其中`0`文件夹是初始状态的一些参数，比如`U`是速度场，`P`是压力场，`T`是温度。

# 一些背景知识

## 1.库朗数

### joe的解读

我们知道，对于流体分析有两种方法，一种是在空间中固定某个控制体，考虑流入控制体的流体的性质，这叫做欧拉法；另一种方式是追踪空间中某个固定的流体，来考虑它的性质，这叫拉格朗日法：一般来说，欧拉法的计算难度相对较小，而我们就考虑在其中一个网格中的流体流过数量。

由于我们计算的过程中，是根据时间步长来进行计算的，那么我们比较理想的情况当然是这个流体流过的距离相对较小，因为这往往意味着它的某些物理性质或者特征我们可以继续利用，并且Co < 1 意味着在一个时间步内，流体信息传播不会越过一个完整的网格单元。这确保了每个网格单元都能正确捕捉到流体的变化，避免了信息的"跳跃"。因此，我们就利用流体在某个步长中流过的距离的除以这个网格大小，来衡量二者的关系，如果小于1，这就意味着网格足够大，相对计算就比较稳定。因此，我们通过在`controlDict`中限制`maxCo`，就可以来动态地控制步长(因为网格大小和流体速度不太好控制)，从而实现数值计算的稳定性。

### 库朗数 (Courant Number) 的定义和含义：

**库朗数**（Courant Number，简称 **Co**）源自数值计算中的 **Courant–Friedrichs–Lewy (CFL) 条件**，它是衡量数值稳定性的重要参数。具体来说，库朗数反映了物质或信息通过网格的一格所需的时间与数值计算中使用的时间步长之间的关系。

库朗数的定义公式为：
$$
C_o = \frac{u \cdot \Delta t}{\Delta x}
$$
其中：

- **`u`** 是流体的局部速度（或流速），
- **`Δt`** 是时间步长，
- **`Δx`** 是网格的空间步长（即网格的大小）。

------

### 库朗数的物理意义：

库朗数衡量的是 **流体在一个时间步长内，通过网格单元的距离与网格单元大小的比例**。其物理意义可以理解为：在时间步长 **`Δt`** 内，流体移动的距离与网格的尺寸（`Δx`）相比有多大。

- **Co < 1**：流体在一个时间步长内移动的距离小于网格单元的大小，这意味着时间步足够小，数值模拟通常是稳定的。
- **Co = 1**：流体在一个时间步长内刚好移动一个网格单元的距离。此时，数值模拟可能处于稳定性边缘。
- **Co > 1**：流体在一个时间步内移动的距离大于网格单元的大小，这意味着信息超出了网格单元，可能导致数值不稳定。

### 为什么库朗数很重要？

在计算流体力学（CFD）中，库朗数是控制数值解稳定性和准确性的关键因素，尤其是对于瞬态（非稳态）模拟。库朗数过大时，数值解可能会变得不稳定，导致模拟结果发散或错误。因此，在瞬态模拟中，通常需要把库朗数控制在一个较小的范围内，以保证数值稳定性和解的准确性。

### 如何控制库朗数？

- **时间步长** (`Δt`)：通过调节时间步长，可以控制库朗数。如果库朗数过大，可以减小时间步长来降低库朗数。
- **网格大小** (`Δx`)：更精细的网格（较小的 `Δx`）会增加库朗数，因此需要相应地减小时间步长。
- **流速** (`u`)：流体速度越大，库朗数越大，因此在高速流动中，时间步长通常必须更小。

### 在 OpenFOAM 中的使用：

在 OpenFOAM 中，`maxCo` 参数用于设置**最大库朗数**，这会影响时间步长的自动调整。当 `maxCo` 被设置为 0.3 时，OpenFOAM 会动态调整时间步长 `Δt`，以确保库朗数不会超过 0.3。这种自动调整机制可以避免数值不稳定，同时确保计算效率。

- **`maxCo 0.3;`** 意味着：模拟中的库朗数不能超过 0.3，以确保数值解的稳定性。

### 总结：

库朗数是数值计算中的关键参数，反映了时间步长、网格大小和流速三者之间的关系。控制库朗数可以确保数值模拟的稳定性和准确性。在 OpenFOAM 中，`maxCo` 参数用于限制库朗数的最大值，以避免模拟中的数值不稳定。如果库朗数太大，可能会导致模拟发散，因此通过调节时间步长来控制库朗数是 CFD 中常见的做法。



----

## 2.OpenFoam中的物理方程

### `joe`的解读

在后面的解读中，我们容易知道，实际上OpenFOAM使用的方程是多种多样的，但是他们有一些共性，即他们方程中有一些共同项，比如说时间导数项，对流项，扩散项等等，这些具有很多共同性质，我们通过组合他们可以形成方程。

同时我们注意到这些项，他们都是偏微分形式，我们无法解方程得到解析解，因此我们采用某些数值方法，来离散化这些偏微分形式，而具体对什么项进行什么样的数值方法的选择，依赖于`fvSchemes`的分配。

**离散化** 是将空间和时间上的偏导数转化为离散的差分或差商形式。这一过程通常基于某种数值方法，如**有限体积法（FVM）**，这是 OpenFOAM 的核心数值方法。

我们利用`fvSchemes`将方程离散化之后，就可以利用一些数值方法来处理计算他们，实质上我们在离散化之后，他们形成的方程形式就是：
$$
A_UU = b_U \quad \text{或者} \quad A_pp = b_p
$$
$$A_u$$ 和 $$A_p$$ 是离散矩阵（来源于离散化后的方程），$$b_U$$ 和 $$b_p$$ 是源项或其他项。

因此我们会使用一些矩阵的方法来求解这些内容，当然由于方程的限制和离散化的方法与结果的不同，矩阵的对称性，正定性，稀疏性都不同，这就意味着我们需要依赖`fvSolutions`来对不同的物理量选择不同的求解方法，以及求解结束的临界条件。例如说:

- 使用 **`upwind`（迎风格式）** 进行对流项离散化，虽然稳定性强，但会引入较大的数值耗散，可能导致矩阵较为稀疏、对称。
- 使用 **`linear`（线性插值）** 进行对流项离散化，可以提高精度，但可能导致矩阵更加复杂，增加求解器的负担。

所以这也意味着，这两个文件应当相互配合，才能得到理想的结果。

### 常用方程

在`OpenFOAM`中，实际上用到了很多方程，

**动量守恒方程（Navier-Stokes 方程）**：
$$
\frac{\partial (\rho \mathbf{U})}{\partial t} + \nabla \cdot (\rho \mathbf{U}\mathbf{U}) = -\nabla p + \nabla \cdot \mathbf{\tau} + \rho \mathbf{g}
\ \ \ 
\begin{align*}
\mathbf{U} &\text{：速度矢量场} \\
p &\text{：压力} \\
\nu &\text{：运动粘度（粘性系数）} \\
\mathbf{F} &\text{：外力（如重力）}
\end{align*}
$$
**质量守恒方程（连续性方程）**:
$$
\frac{\partial \rho}{\partial t} + \nabla \cdot (\rho \mathbf{U}) = 0
\ \ \ \ 
\begin{align*}
\rho &\text{：密度} \\
\mathbf{U} &\text{：速度矢量场}
\end{align*}
$$
**能量方程(用于描述热传导)**:
$$
\rho c_p \left( \frac{\partial T}{\partial t} + \mathbf{U} \cdot \nabla T \right) 
= \nabla \cdot (\kappa \nabla T) + S_T
\ \ \ \ 
\begin{align*}
T &\text{：温度} \\
\rho &\text{：流体密度} \\
c_p &\text{：定压比热容} \\
\kappa &\text{：热导率} \\
S_T &\text{：热源项}
\end{align*}
$$
等等等等，相当多，这些内容实际上也并不是我们需要关心的，我们关键应该从这个角度来观察方程:

### 方程解法

这些方程是无法得到精确数值解的，因此我们考虑使用的是离散分析，也就是采用一些方法或者原则来把这些偏微分和常微分来进行一些模拟，而这就是在`fvSchemes`中我们规定的

**实际上，这些方程的格式虽然不同，但是他操作的项往往都是有限的，我们在具体操作的时候，只需要关注这些项就可以了**

**我们可以利用这些常见项来组合形成我们需要见到的方程，这给我们带来了一个很好的方法，即我们完全可以通过约束这些常见项来进行数值模拟**

### 方程的常见项

#### 1.**时间导数项（Transient Term）**

时间导数项描述物理量随时间的变化，常用于非稳态问题。
$$
\frac{\partial \phi}{\partial t}
$$

- 其中，*ϕ* 表示物理量（如速度、温度、浓度等）。
- **解释**：表示物理量*ϕ* 随时间 *t* 的变化率。

#### 2.**对流项（Convective Term）**

对流项描述流体流动过程中的物理量传递。对于一个标量*ϕ* 的对流项可以表示为：
$$
\nabla \cdot (\mathbf{U} \phi)
$$

- 其中，**U** 是速度场，*ϕ* 是传递的物理量（如温度、质量分数等）。
- **解释**：表示物理量 *ϕ* 随流体速度场 **U** 的传递。

#### 3.**扩散项（Diffusive Term）**

扩散项描述物理量由于梯度而在空间中扩散。对于标量 *ϕ* 的扩散项可以表示为：
$$
\nabla \cdot (\Gamma \nabla \phi)
$$

- 其中，Γ 是扩散系数（如热导率、动量扩散系数等），*ϕ* 是物理量。
- **解释**：表示物理量 *ϕ* 在扩散系数 Γ 作用下的扩散。

#### 4.**压力梯度项（Pressure Gradient Term）**

压力梯度项描述压力推动流体流动的效应。常在动量方程中出现，表示为：
$$
-\nabla p
$$

- 其中，*p* 是压力。
- **解释**：表示压力差驱动流体运动的力。

#### 5.**源项（Source Term）**

源项描述外部对系统的作用力或能量输入。源项可以有不同的形式，通常是一个函数 *S*(*ϕ*)，例如：
$$
S(\phi)
$$

- **解释**：*S*(*ϕ*) 可以表示热源、质量生成、化学反应等。对于动量方程中的体积力（如重力）源项，通常写为：

$$
\mathbf{F}
$$

- **解释**：**F** 是外部作用的体积力，如重力*ρg*。

#### 6. **拉普拉斯项（Laplacian Term）**

拉普拉斯项是扩散项的一种特殊形式，常用于描述热传导或扩散过程。形式为：
$$
\nabla^2 \phi
$$

- **解释**：这是 *ϕ* 的拉普拉斯算子，表示物理量 *ϕ* 的扩散或传导。

#### 7.**湍流动能生成项（Turbulence Production Term）**

在湍流模型中，湍流动能生成项 *Pk* 表示湍流动能的生成，通常形式为：
$$
P_k = \nu_t \left( \nabla \mathbf{U} : \nabla \mathbf{U} \right)
$$

- 其中，*νt* 是湍流粘性系数，∇**U** 是速度梯度。
- **解释**：表示湍流动能的产生，通常与速度梯度和湍流粘性系数相关。

#### 8.**湍流耗散项（Turbulence Dissipation Term）**

湍流耗散项 *ϵ* 表示湍流动能的耗散。形式为：
$$
\epsilon = C_\mu \frac{k^2}{\epsilon}
$$

- 其中，*C**μ* 是一个常数，*k* 是湍流动能，*ϵ* 是耗散率。
- **解释**：表示湍流动能通过耗散速率 *ϵ* 的损失。

#### 9. **质量通量项（Mass Flux Term）**

质量通量项用于描述质量传输，通常在物质传输方程中使用。形式为：
$$
\mathbf{J} = \rho \mathbf{U} Y_i
$$

- 其中，**J** 是质量通量，*ρ* 是密度，U** 是速度场，Yi* 是组分质量分数。
- **解释**：表示流体中组分 *Yi* 的传递。

# 一.System文件夹

## 1.controlDict文件

### 简介

**`controlDict`** 是每个模拟案例的核心配置文件之一，位于 `system` 文件夹内。它的主要作用是**控制模拟的总体运行流程和输出行为**，包括时间步长、输出频率、文件格式等。这个文件相当于 OpenFOAM 中的“控制面板”，用户可以根据需求调整模拟的执行参数。

<img src="C:\Users\Administrator\Desktop\OpenFOAM学习\photos\controlDict.png" alt="controlDict" style="zoom:80%;" />

### 各参数项含义

* 1.头文件:

  ```c++
  FoamFile
  {
      format      ascii;
      class       dictionary;
      location    "system";
      object      controlDict;
  }
  ```

  这是 OpenFOAM 文件的标准头信息，描述文件的格式与类型。

  - **`format ascii;`**：文件格式为 `ascii`，表示文件以纯文本形式存储（另一种可能的选择是 `binary`，即二进制格式）。
  - **`class dictionary;`**：表明这是一个字典类文件。
  - **`location "system";`**：文件所在的路径是 `system` 文件夹。
  - **`object controlDict;`**：该文件的名称是 `controlDict`，用于控制模拟的运行。

* 2.求解器名称设置
  `application     icoFoam;`

  指定要运行的求解器名称，这里实际上也可以去使用其余名称，在外部使用的时候，其实还是用`icoFoam`来执行，但是这里的名称是因为在脚本中会读取这个名称。

* 3.时间控制

  时间控制有几个项来控制，通过 `startTime`、`endTime` 和 `deltaT` 控制模拟的起始时间、结束时间和时间步长。其中主要是分为控制起始终止时间和时间步长。

  * `startFrom       startTime;`
    - 作用：指定从哪一个时间步开始运行模拟。
      - **`startTime`** 表示模拟从指定的开始时间（`startTime`）处启动。
      - 其他可能的选项：
        - **`latestTime`**：从上一次模拟的最后一个时间步重新启动（常用于重新启动中断的模拟）。
        - **`firstTime`**：从最早的时间步开始模拟。
  * `startTime       0;`
    - 作用：指定模拟的起始时间。是与前一项联合起来使用的，如果前一项不是`startTime`，那这一项没有意义
  * `stopAt          endTime;`
    - 作用：定义模拟何时停止。
      - **`endTime`** 表示模拟将在指定的结束时间停止。
      - 其他可能的选项：
        - **`writeNow`**：完成当前时间步后立即停止并输出数据。
        - **`noWriteNow`**：完成当前时间步后立即停止但不输出数据。
  * `endTime         0.5;`
    - 作用：定义模拟的结束时间。与`startTime`是类似的，如果在`stopAt`中没有定义，那么这一项也没有意义。
  * `deltaT          0.005;`
    - 作用：定义时间步长。
      - **`0.005`** 表示每个时间步的步长为 `0.005` 秒。时间步长越小，模拟的精度越高，但计算时间也会相应增加。

* 4.输出控制

  通过 `writeControl`、`writeInterval`、`writeFormat` 等参数控制输出数据的频率、格式及精度。

  * `writeControl    timeStep;`

    - 作用：控制输出数据的频率。
      - **`timeStep`** 表示根据时间步数来控制输出数据的频率。
      - 其他可能的选项：
        - **`runTime`**：根据模拟的运行时间（物理时间）来控制输出频率。
        - **`adjustableRunTime`**：根据可调节的运行时间来控制输出频率。

  * `writeInterval   20;`

    - 作用：指定输出文件的时间步间隔。
      - **`20`** 表示每隔 20 个时间步输出一次数据。结合上面的 `deltaT`，这意味着每隔 `20 × 0.005 = 0.1` 秒输出一次结果。

  * `purgeWrite      0;`（purgeWrite的中文含义是清除写入）

    - 作用：控制保留的输出文件数量。
      - **`0`** 表示保留所有输出文件，不删除任何输出文件。
      - 如果设置为其他正数（如 `2` 或 `5`），则只保留最新的 `n` 个输出文件，较早的文件会被删除，以节省磁盘空间。

  * `writeFormat     ascii;`

    - 作用：指定输出文件的格式。
      - **`ascii`** 表示以纯文本形式输出数据，易于阅读和修改。
      - 另一种可能的格式是 **`binary`**，二进制格式虽然难以阅读，但文件体积较小，适合大规模计算时使用。

  * `writePrecision  6;`

    - 作用：控制输出文件中数值的精度。
      - **`6`** 表示输出文件中的数值保留 6 位有效数字。

  * `writeCompression off;`

    * 作用：控制输出文件是否进行压缩。
      - **`off`** 表示输出文件不进行压缩。
      - 如果设置为 **`on`**，则输出文件会被压缩，以节省磁盘空间。

  * `timeFormat      general;`

    * 作用：指定时间格式。
      - **`general`** 表示使用一般的时间格式（自动选择最合适的格式）。
      - 其他可能的选项包括 **`fixed`** 和 **`scientific`**，可以分别输出固定小数点格式或科学计数法格式。

  * `timePrecision   6;`

    - 作用：控制输出文件中时间的精度。
      - **`6`** 表示输出文件中的时间值保留 6 位有效数字。

  * `runTimeModifiable true;`

    作用：允许在模拟过程中修改控制文件。

    - **`true`** 表示在模拟运行时，每个时间步结束后，OpenFOAM 会重新读取 `controlDict` 文件，因此可以在模拟进行时修改控制参数并实时生效。
    - 如果设置为 **`false`**，模拟运行过程中不能动态修改控制文件。

* 特殊的，动态调整时间步长的选项

  ```c++
  adjustTimeStep  yes;
  maxCo           0.3;
  ```

  `maxCo`（最大库朗数）是 OpenFOAM 中用于**动态调整时间步长**的一个重要参数，通常**用于瞬态模拟**以确保数值稳定性。这个参数通常与 `adjustTimeStep` 配合使用，允许根据 Courant 数自动调整时间步长。然而，这个参数并不是所有案例或求解器的必需项，它的存在与否取决于具体的求解器和模拟类型。

  **`icoFoam`** 是一个用于**不可压缩流体瞬态模拟**的求解器。对于这个求解器来说，默认情况下时间步长可以是固定的，因此可能不需要根据 Courant 数动态调整时间步长。

  * `adjustTimeStep yes;`启动动态时间长调整
  * `maxCo 0.3;`意味着控制最大库朗数。

## 2.fvSchemes文件

<img src="C:\Users\Administrator\Desktop\OpenFOAM学习\photos\fvSchemes.jpg" alt="fvSchemes" style="zoom:80%;" />

### 简介

[注意到这里我们介绍了OpenFOAM中拼接各项形成方程的思路](#`joe`的解读)

OpenFOAM 使用的是**有限体积法（Finite Volume Method, FVM）**，其基本思路是将方程中的连续项（如对流项、扩散项）离散化为离散的线性代数方程，然后通过求解这些代数方程来得到物理量的数值解。

每个物理项都会根据不同的离散格式（如**迎风格式**、**中心差分**等）进行离散化。而 OpenFOAM 通过 `fvSchemes` 文件来定义这些项的离散方法。

### 各项含义和作用

#### 1.**时间离散项（time schemes）**

```c++
ddtSchemes
{
    default Euler;
}
```

常见的方法包括：

- **Euler**：显式欧拉方法。
- **backward**：隐式后向差分法（常用于稳态计算）。
- **CrankNicolson**：隐式的 Crank-Nicolson 方法，通常用于非稳态问题。

   #### 2.**对流项离散（div schemes）**

```c++
divSchemes
{
    default none;
    div(phi,U) Gauss upwind;
    div(phi,T) Gauss linearUpwind grad(T);
}
```

- **upwind**：迎风格式，适合处理高雷诺数流动中的对流主导问题，数值稳定，但精度较低。
- **linearUpwind**：线性迎风格式，较高阶的迎风方法，精度高于普通迎风格式。
- **central differencing**：中心差分格式，适用于低雷诺数问题，精度较高但可能会产生数值振荡。

在上面的例子中：

- `div(phi,U)` 定义的是速度对流项的离散化，使用的是迎风格式。
- `div(phi,T)` 定义的是温度的对流项，使用的是线性迎风格式。

#### 3.**扩散项离散（grad 和 laplacian schemes）**

在 `fvSchemes` 中，扩散项的离散化方法可以通过 `gradSchemes` 和 `laplacianSchemes` 来定义：

##### 1.gradSchemes

用于定义梯度项的离散方法。通常使用中心差分格式。

```c++
gradSchemes
{
    default Gauss linear;
}
```

##### 2.**laplacianSchemes**

用于定义拉普拉斯项的离散方法。常规的选项是有限体积法中的 Gauss 积分格式。

```c++
laplacianSchemes
{
    default Gauss linear corrected;
}
```

- `Gauss linear` 表示使用高斯公式和线性差分来离散化梯度和拉普拉斯项。
- `corrected` 是一种修正格式，用于提高非正交网格下的精度。

#### 4.**插值格式（interpolation schemes）**

插值格式用于在离散网格上将物理量从网格中心插值到面心，常见的插值方法包括：

- **linear**：线性插值。
- **cubic**：三次插值，精度更高。

```c++
interpolationSchemes
{
    default linear;
}
```

#### 5.**`snGradSchemes`（表面法向梯度的离散化）**

#### **表面法向梯度对应的方程部分：**

**表面法向梯度**是指在网格面上的物理量梯度，尤其在处理**非正交网格**时，法向梯度的计算非常重要。法向梯度通常出现在对流和扩散项的离散化过程中。

#### **表面法向梯度的离散化：**

`snGradSchemes` 用来指定如何计算表面法向梯度。

```c++
snGradSchemes
{
    default          orthogonal;   // 进行非正交修正
}
```

### 总结：各项离散化设置对应的方程

- **`gradSchemes`**：用于离散化梯度项，出现在对流和扩散项中，涉及动量方程、能量方程等。
- **`divSchemes`**：用于离散化对流项，出现在动量方程、能量方程中，描述物理量的流动。
- **`laplacianSchemes`**：用于离散化扩散项，出现在扩散现象相关的方程中，如粘性项、导热项等。
- **`interpolationSchemes`**：用于插值物理量，出现在通量计算中。
- **`snGradSchemes`**：用于计算表面法向梯度，特别是在非正交网格中，对对流和扩散项都有影响。
- **`fluxRequired`**：用于指定是否计算通量，主要用于后处理分析。

## 3.fvSolutions文件

<img src="C:\Users\Administrator\Desktop\OpenFOAM学习\photos\fvSolutions.jpg" alt="fvSolutions" style="zoom:80%;" />

根据[上面提到的fvSchemes和fvSolutions关系](#OpenFoam中的物理方程)，我们知道`fvSolutions`实际上是在对不同的物理量的不同线性代数方程采用不同的解法，它定义了对于不同的物理量（如 `p`、`U`、`k`、`\epsilon` 等）所使用的求解器以及求解的终止条件（如残差容差 `tolerance` 和相对容差 `relTol`）。例如：

- 对于对称正定的压力泊松方程，常常使用**预条件共轭梯度法（PCG）**。
- 对于非对称的速度方程，常常使用**预条件双共轭梯度法（PBiCG）**。

常见矩阵有:

- **对称正定矩阵**：通常出现在压力方程中，可以使用预条件共轭梯度法（PCG）来求解。
- **非对称矩阵**：例如速度方程，通常使用预条件双共轭梯度法（PBiCG）或其他适合非对称矩阵的求解器。
- **大规模问题**：对于非常大的网格或复杂的几何问题，使用多重网格求解器（如 GAMG）可以显著提高求解效率。

所以这里基本上定义的就是`solver(求解器)`，`preconditioner(前处理)`，`tolerance(绝对容差)`，`relTol(相对容差)`.

比如我们考虑`p`

- **求解器：PCG (Preconditioned Conjugate Gradient Solver)**
  PCG 是一种适合求解**对称正定矩阵**的迭代求解器。压力泊松方程通常会生成对称正定矩阵，因此使用 PCG 是合适的选择。
- **预处理器：DIC (Diagonal Incomplete Cholesky)**
  DIC 是常见的预处理器，它通过对矩阵进行近似分解，旨在加速迭代求解的收敛。DIC 是对角不完全Cholesky分解，适用于对称正定矩阵。
- **绝对容差：`tolerance = 1e-06`**
  这是迭代求解的**绝对残差容差**，当残差小于这个值时，迭代终止。设置较小的绝对容差可以提高结果的精度。
- **相对容差：`relTol = 0.05`**
  **相对容差**控制残差相对变化的终止条件。当残差在一次迭代后相对于前一次迭代变化小于 5% 时，迭代终止。设置相对容差可以避免过多的迭代，节省计算时间。

也可以注意`pfinal`

- **`pFinal`** 代表最后一个时间步或稳态求解的最终压力解设置。
  这里使用了 `$p`，表示继承上面 `p` 的求解设置（即 `PCG` 和 `DIC`）。
  不过，相对容差被设置为 `0`，意味着在最终求解时，**不使用相对容差限制**，即只依据绝对容差来判定是否收敛。

## 4.blockMeshDict文件

### joe的解读(blockMeshDict)

在后面的[`constant/polymesh`的解读中](#polymesh文件夹)，我们知道`polymesh`是记载网格的相关信息的文件夹，对于一个完整的网格结构来说，是需要一系列因素来确定的，我们很容易想到:

* point，用于记录点
* face，用于记录面
* neighbour:用于记录面之间的拓扑关系从而拼接
* owner:用于记录面属于哪个单元
* boundary:边界的有关属性，是什么属性`wall,patch`等

但是`polymesh`并非是本身就有的，他所依赖的就是`system/blockMesh`文件中的内容，而`blockMesh`是一个大的文件，它的格式就类似于:

```c++
someAttributes
    (
);
```

而实际上他这些属性也是为上面的内容做一些铺垫。

真正的`blockMeshDict`的内容就是如下图所示:

<img src="C:\Users\Administrator\Desktop\OpenFOAM学习\photos\blockMesh.jpg" alt="blockMesh" style="zoom:80%;" />

![cavity算例的blockMeshDict介绍](C:\Users\Administrator\Desktop\OpenFOAM学习\photos\cavity算例的blockMeshDict介绍.jpg)

![边界条件说明](C:\Users\Administrator\Desktop\OpenFOAM学习\photos\边界条件说明.jpg)

* `convertToMeters`:这是一个缩放因子，因为`openFOAM`中默认的单位都是一米，因此如果我们对网格的顶点坐标的长度的单位要求为厘米，那我们就可以用`convertToMeters 0.01`,也就是把整个图的比例尺放缩一下

* `vertices(中文为顶点)`:这是一个顶点坐标的列表，而列表的列出是需要遵循右手法则的(点的列出是不需要的，但是考虑到在后面`blocks`中需要使用右手法则制造块，所以还是需要考虑使用这方面的内容)

* `blocks`：这是一个块的定义列表。每个块由若干个顶点组成，并定义了网格的尺寸（即每个方向上有多少个网格单元）。块是网格的基本单元，如六面体（hex）

  ```c++
  blocks
      (
  hex(0 1 2 3 4 5 6 7)(20 20 1)simpleGrading(1 2 3))
  ```

  * 其中`hex`是指这是六面体网格，而六面体(比如说长方体)，有8个顶点，后续第一个括号内内容就是这8个点。**通过顶点来声明block的时候，要注意使用右手法则**，这里注意到这个图，局部坐标系的形式，是这样认为的:`0->1`为x轴方向，`1->2`为y轴方向，`0->4`为z轴方向。![网格划分的示意图](C:\Users\Administrator\Desktop\OpenFOAM学习\photos\网格划分的示意图.png)
  * 第二个括号`(20 20 1)`指的是每个方向上的网格单元划分。分别是 x、y 和 z 三个方向上的划分数。
  * **`simpleGrading`** 用于控制网格单元的大小变化，即网格的**扩展比**。它定义了网格单元在每个方向上的扩展比例，使得网格从一侧到另一侧的单元大小可以发生变化。这个数字意味着沿着这个方向扩展到最后一个的时候，最后一个单元的尺寸和第一个单元尺寸的关系
    - **1**：在 x 方向上，所有网格单元的大小是均匀的（即网格单元在 x 方向上没有扩展或收缩）。
    - **2**：在 y 方向上，网格单元从一侧到另一侧的大小会逐渐增加，最大单元大小是最小单元大小的 2 倍。
    - **3**：在 z 方向上，网格单元的扩展比为 3，意味着网格单元在 z 方向上的大小会逐渐增大，最大单元大小是最小单元大小的 3 倍。

* `edges(边界曲线)`:`edges` 部分允许你为六面体块的某些边定义曲线或圆弧，这在处理圆柱体或曲面时特别有用。

  * ```c++
    edges
    (
        arc 0 1 (0.5 0.5 0)  // 定义从顶点0到顶点1的一段圆弧，弧的中点为(0.5 0.5 0)
    );
    ```

* `boundary`（边界条件)`:`boundary` 定义了几何体的物理边界，并将它们命名以便在仿真中指定不同的边界条件（如入口、出口、壁面等

  * ```c++
    boundary
    (
        inlet
        {
            type patch;
            faces
            (
                (0 4 7 3)  // 定义一个面，由四个顶点组成
            );
        }
        outlet
        {
            type patch;
            faces
            (
                (0 3 2 1)  // 定义另一个面
            );
        }
    );
    ```

  * 每个边界面由**四个顶点**定义。**顶点顺序**非常重要，必须遵循从块**内部观察**，顶点按**顺时针方向**排列规则。这里我们可以回看上面那张图，可以知道`0 4 7 3`为一个面

  * 边界类型

    * **`patch`**：通用类型，没有几何或拓扑信息，适用于各种边界条件。
    * **`wall`**：用于固体壁面，常用于湍流模拟中的壁面函数。
    * **`symmetryPlane`**：对称平面，定义流场的对称性。
    * **`empty`**：用于 2D 或 1D 模拟，适用于某些维度不需要解的情况。
    * **`cyclic`**：周期性边界，两个边界被视为物理上连接的。
    * **`processor`**：用于并行计算时，描述处理器之间的边界。

# 二.constant文件夹

**`constant` 文件夹** 是 OpenFOAM 仿真中存储物理模型、材料属性和网格信息的关键目录。

## **1. `physicalProperties` 文件**

如果有其余的物理信息，会有其他文件，比如 `transportProperties`、`RASProperties` 等

- **作用**：该文件通常用于定义流体或其他物理物质的特性。在仿真中，涉及的物质属性（如密度、粘度、比热容等）会存储在这个文件中。

- **内容**：文件中定义的物理属性可能会根据具体的物理问题而有所不同。举例来说，如果你在做流体流动仿真，`physicalProperties` 文件可能包含如下内容：

  ```
  transportModel  Newtonian;
  
  rho             [1 -3 0 0 0 0 0] 1.225;  // 密度 (kg/m³)
  nu              [0 2 -1 0 0 0 0] 1.5e-5;  // 动力粘度 (m²/s)
  ```

  - `rho`：定义流体的密度。
  - `nu`：定义流体的动力粘度（对于不可压缩流体，这是常见的定义方式）。

  这个文件的具体内容会根据仿真类型的不同而有所变化。如果你进行的是多相流仿真，可能还会有其他与多相流相关的物性参数。

## **2.`polyMesh`**文件夹

- **作用**：`polyMesh` 目录存储网格数据（如节点、面、单元等）。它是 OpenFOAM 中非常重要的目录，所有 CFD 仿真计算都基于这些网格节点进行。

- **常见文件**：

  - `points`：存储所有网格节点的坐标。**格式**：每行表示一个节点的坐标，格式为 `(x y z)`。

    ```c++
    8
    (
        (0 0 0)
        (1 0 0)
        (1 1 0)
        (0 1 0)
        (0 0 1)
        (1 0 1)
        (1 1 1)
        (0 1 1)
    )
    ```

  - `faces`：定义网格的面，每个面由若干个点组成。**格式**：每行表示一个面，每个面由若干个点组成，点的编号来自 `points` 文件。

    ```c++
    12
    (
        (0 1 5 4)
        (1 2 6 5)
        (2 3 7 6)
        (3 0 4 7)
        (0 3 2 1)
        (4 5 6 7)
    )
    ```

  - `owner`：定义每个面所属的单元（即面在哪个单元内部）。**格式**：每行表示一个面所属的单元编号，面与单元的关系是单向的，即这个面属于某个单元的内部。

    ```c++
    12
    (
        0
        0
        0
        0
        0
        0
    )
    ```

  - `neighbour`：定义每个面与相邻单元的关系。**格式**：每行表示一个面与相邻单元的编号，表示该面与某个单元共享。

    ```c++
    12
    (
        1
        1
        1
        1
        1
        1
    )
    ```

  - `boundary`：定义网格的边界条件。**格式**：每个边界有一个名称、类型（如 `patch`、`wall`、`symmetryPlane` 等），以及边界面列表。

    ```c++
    2
    (
        inlet
        {
            type patch;
            faces
            (
                (0 1 5 4)
            );
        }
        outlet
        {
            type patch;
            faces
            (
                (2 3 7 6)
            );
        }
    )
    ```

  - **`cells` 文件（可选）**

    - **作用**：定义每个网格单元的几何形状或体积信息。在一些复杂的非结构化网格中，`cells` 文件会被用来明确每个网格单元的几何信息。

# 三.0文件夹

![cavity算例图](C:\Users\Administrator\Desktop\OpenFOAM学习\photos\cavity算例图.jpg)

 我们在[关于几何边界条件的解读中](#joe的解读(blockMeshDict))，提到过:**边界条件分为两种，一种为物理边界条件，一种为几何边界条件**，在`system/blockMeshDict`文件中，我们提到过限制边界条件，尤其是对于固定界面:`fixedWall`，可动界面`movingWall`，前后界面等等`frontAndBack`。而对于相应的数据，我们也应该做相应的物理因素的确定。

比如说`U`文件:

![U文件的量纲说明](C:\Users\Administrator\Desktop\OpenFOAM学习\photos\U文件的量纲说明.jpg)

其中`dimensions`是物理学的七大量纲，通过组合我们能够得到所有量纲。

第二个`internalField`是指内部场，这个uniform(0 0 0)代表x y z方向的内部场速度分量都是0.

其中地下的`boundaryFiled`就是边界场的内容了，这必须要与`blockMeshDict`中规定的几何边界的名称与内容相同

我们再来看`p`文件

![p文件的内容1](C:\Users\Administrator\Desktop\OpenFOAM学习\photos\p文件的内容1.jpg)

![p文件的内容2](C:\Users\Administrator\Desktop\OpenFOAM学习\photos\p文件的内容2.jpg)
